<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Navigation Game with Compass</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/jeromeetienne/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }
      #debug-log {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0,0,0,0.7);
        color: white;
        font-size: 12px;
        padding: 10px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 1000;
      }
      #game-ui {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 10px 20px;
        text-align: center;
        background-color: rgba(255, 255, 255, 0.9);
        z-index: 100;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      #error-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        display: none;
        z-index: 1000;
      }
      /* Rest of the previous CSS remains the same */
    </style>
  </head>
  <body>
    <div id="error-message"></div>
    <div id="debug-log"></div>
    <div id="game-ui">
      <p id="clue-message">Press Start to reveal the clue and begin navigation.</p>
      <p id="status-message">Press Start to begin navigation.</p>
      <button id="start-button" onclick="requestPermissionsAndStartGame()">Start Navigation</button>
    </div>
    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;">
      <a-assets timeout="5000">
        <a-asset-item id="target-model" src="AnimatedRalphie.glb"></a-asset-item>
      </a-assets>
      <a-entity
        id="target-model-entity"
        gps-entity-place
        scale="1.5 1.5 1.5"
        visible="false"
        gltf-model="#target-model">
      </a-entity>
      <a-camera gps-camera rotation-reader></a-camera>
    </a-scene>
    <script>
      // Debug logging function
      function debugLog(message) {
        const logElement = document.getElementById('debug-log');
        const logEntry = document.createElement('div');
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logElement.appendChild(logEntry);
        logElement.scrollTop = logElement.scrollHeight;
        console.log(message);
      }

      // Error handling function
      function showError(message) {
        debugLog(`ERROR: ${message}`);
        const errorElement = document.getElementById('error-message');
        errorElement.textContent = message;
        errorElement.style.display = 'block';
      }

      // Game configuration
      const DESTINATION_THRESHOLD = 20; // meters
      const VISIBILITY_THRESHOLD = 50; // meters to make model visible

      // Predefined locations (simplified for testing)
      const locations = [
        { 
          latitude: 40.007154, 
          longitude: -105.270400, 
          clue: "Test Location 1" 
        }
      ];

      // Game state variables
      let targetLocation = null;
      let gameStarted = false;
      let watchId = null;
      let currentHeading = 0;
      let currentLocation = null;

      // Request permissions and start game
      function requestPermissionsAndStartGame() {
        debugLog('Requesting permissions');
        
        if (!navigator.geolocation) {
          showError('Geolocation is not supported by this browser.');
          return;
        }

        // Request location permission
        navigator.geolocation.getCurrentPosition(
          (position) => {
            debugLog(`Initial position: ${position.coords.latitude}, ${position.coords.longitude}`);
            
            // Try to request device orientation permission (for iOS)
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
              DeviceOrientationEvent.requestPermission()
                .then(response => {
                  if (response === 'granted') {
                    startGame(position);
                  } else {
                    showError('Device orientation permission denied');
                  }
                })
                .catch(error => {
                  showError(`Orientation permission error: ${error}`);
                });
            } else {
              // For browsers that don't require explicit permission
              startGame(position);
            }
          }, 
          (error) => {
            showError(`Location permission error: ${error.message}`);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      }

      // Start the game
      function startGame(initialPosition) {
        debugLog('Starting game');
        
        if (gameStarted) return;

        gameStarted = true;
        document.getElementById("start-button").style.display = "none";

        // Use the first location from our predefined list
        targetLocation = locations[0];
        
        debugLog(`Target Location: ${JSON.stringify(targetLocation)}`);

        // Start location tracking
        try {
          watchId = navigator.geolocation.watchPosition(
            onLocationUpdate, 
            onLocationError, 
            {
              enableHighAccuracy: true,
              timeout: 20000,
              maximumAge: 0
            }
          );
        } catch (error) {
          showError(`Failed to start location watch: ${error.message}`);
        }
      }

      // Handle location updates
      function onLocationUpdate(position) {
        try {
          debugLog(`Location Update: ${JSON.stringify(position.coords)}`);

          // Ensure we have a target location
          if (!targetLocation) {
            showError('No target location set');
            return;
          }

          const { latitude, longitude } = position.coords;
          currentLocation = { latitude, longitude };
          
          // Calculate distance
          const distance = calculateDistance(
            latitude, longitude, 
            targetLocation.latitude, 
            targetLocation.longitude
          );
          
          // Calculate bearing
          const bearing = calculateBearing(
            latitude, longitude, 
            targetLocation.latitude, 
            targetLocation.longitude
          );

          debugLog(`Distance: ${distance}m, Bearing: ${bearing}Â°`);

          // Update AR model visibility
          const modelEntity = document.getElementById("target-model-entity");
          if (distance <= VISIBILITY_THRESHOLD) {
            modelEntity.setAttribute('visible', 'true');
            debugLog('Model made visible');
          } else {
            modelEntity.setAttribute('visible', 'false');
          }
        } catch (error) {
          showError(`Location update error: ${error.message}`);
        }
      }

      // Calculate distance between two coordinates
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // Earth's radius in meters
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const a = 
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) * Math.cos((lat2 * Math.PI) / 180) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // Calculate bearing between two coordinates
      function calculateBearing(lat1, lon1, lat2, lon2) {
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const lat1Rad = (lat1 * Math.PI) / 180;
        const lat2Rad = (lat2 * Math.PI) / 180;
        const y = Math.sin(dLon) * Math.cos(lat2Rad);
        const x = 
          Math.cos(lat1Rad) * Math.sin(lat2Rad) -
          Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
        return ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;
      }

      // Handle location tracking errors
      function onLocationError(error) {
        debugLog(`Location Error: ${error.message}`);
        
        let errorMessage = "An unknown error occurred while tracking location.";
        
        switch(error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = "Location permission denied. Please enable location services.";
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = "Location information is unavailable.";
            break;
          case error.TIMEOUT:
            errorMessage = "Location request timed out.";
            break;
        }
        
        showError(errorMessage);
      }

      // Global error handling
      window.onerror = function(message, source, lineno, colno, error) {
        showError(`Global Error: ${message} at ${source}:${lineno}`);
        return false;
      };
    </script>
  </body>
</html>
